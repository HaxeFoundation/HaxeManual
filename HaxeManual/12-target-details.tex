\chapter{Target Details}
\label{target-details}
\state{NoContent}

\section{Accessing Target-specific Syntax}
\label{target-syntax}

When writing code for a particular target, it might be necessary to access certain features that are only available on that target and inaccessible in Haxe code. It is still possible to access these features using the target-specific \type{Syntax} APIs:

\begin{itemize}
	\item \href{https://api.haxe.org/v/development/js/Syntax.html}{\type{js.Syntax}} - JavaScript syntax
	\item \href{https://api.haxe.org/v/development/php/Syntax.html}{\type{php.Syntax}} - PHP syntax
	\item \href{https://api.haxe.org/v/development/python/Syntax.html}{\type{python.Syntax}} - Python syntax
\end{itemize}

\emph{Important note:} Before using these functions, make sure there is no alternative available in the Haxe Standard Library. The resulting syntax can not be validated by the Haxe compiler, which may result in invalid or error-prone code in the output.

\paragraph{\expr{Syntax.code(expr, args...)}}
\since{4.0.0}

Injects raw code expressions. The expression is a string which may include \expr{\{0\}}, \expr{\{1\}}, \expr{\{2\}}, etc. - these are replaced with the corresponding arguments provided to the function. This is important if the code needs to reference Haxe fields, since the names of variables in the generated output may not correspond to their names in Haxe code. The Haxe compiler will take care of adding quotes if strings are provided. The function can also return values, although the return type is always \type{Dynamic}.

An example of \expr{js.Syntax.code}:

\begin{lstlisting}
var myMessage = "Is Haxe great?";
var output:Bool = Syntax.code("confirm({0})", myMessage);
\end{lstlisting}

The generated JavaScript output is:

\begin{lstlisting}
var myMessage = "Is Haxe great?";
var output = confirm(myMessage);
\end{lstlisting}

Other functions are documented in the corresponding API sections. These generally include native operators that are not available in Haxe.

\paragraph{Other platforms}

It is planned to implement \type{Syntax} APIs for other targets in future releases. For the time being, it is still possible to access target-specific syntax on some of the other platforms, albeit in a less type-safe manner, using an \tref{\expr{untyped}}{type-system-untyped} expression:

\begin{itemize}
	\item[C++] \expr{untyped __cpp__(expr, args...)}
	\item[C\#] \expr{untyped __cs__(expr, args...)}
	\item[Java] \expr{untyped __java__(expr, args...)}
	\item[Lua] \expr{untyped __lua__(expr, args...)}
\end{itemize}

The arguments for these follow exactly the same semantics as \expr{Syntax.code}.

\section{JavaScript}
\label{target-javascript}

Haxe provides the ability to target JavaScript. It does so by transpiling Haxe to JavaScript. The current implementation targets ECMAScript 5. But it is possible to target lower versions using \ic{-D js-es=<value>}.

When choosing the JavaScript target, only the used Haxe code of the project (and used parts of the standard library) are transpiled to JavaScript. This results in optimal filesize which is also readable. \tref{Source maps}{debugging-source-map-javascript} are available and there are several ways to get \tref{debug}{debugging} information. The standard library aims to have same functionality across all targets.

\paragraph{Usage}

You may want to compile Haxe to JavaScript in the following scenarios:

\emph{Client-side JavaScript}
Interacting with DOM elements. Haxe provides up to date typed interfaces to interact with the Document Object Model, allowing creation and update of DOM elements. 

Haxe can be used together with existing third-party libraries and frameworks, such as jQuery, React or Vue. To access third-party frameworks with a strongly-typed API, there are extern libraries available on \href{http://lib.haxe.org/t/js/}{Haxelib}. Alternatively, it is possible to create own externs (see \Fullref{target-javascript-external-libraries}) or use the dynamic type to access any framework, see \Fullref{target-syntax}.

\emph{Creating graphics using Canvas and WebGL}
Use Haxe to create graphical elements on a web page using WebGL. 

Libraries like \href{http://www.openfl.org/}{OpenFL}, \href{http://heaps.io/}{Heaps} and \href{http://kha.tech/}{Kha} make use of WebGL as one of their backends.

\emph{Creating Haxe code that targets server-side JavaScript}
Working with server-side technology. Haxe can be used to create server-side JavaScript like Node.js.

\Fullref{target-javascript-getting-started}

\subsection{Getting started with Haxe/JavaScript}
\label{target-javascript-getting-started}

Haxe can be a powerful tool for developing JavaScript applications. Let's look at our first sample.
This is a very simple example showing the toolchain. 

Create a new folder and save this class as \ic{Main.hx}.

\begin{lstlisting}
import js.Browser;
class Main {
    static function main() {
        var button = Browser.document.createButtonElement();
        button.textContent = "Click me!";
        button.onclick = function(event) {
            Browser.alert("Haxe is great");
        }
        Browser.document.body.appendChild(button);
    }
}
\end{lstlisting}

To compile, either run the following from the command line:

\lang{hxml}\begin{lstlisting}
haxe --js main-javascript.js --main Main
\end{lstlisting}

Another possibility is to create and run (double-click) a file called \ic{compile.hxml}. In this example the hxml file should be in the same directory as the example class.

\lang{hxml}\begin{lstlisting}
--js main-javascript.js
--main Main
\end{lstlisting}

The output will be a main-javascript.js, which creates and adds a clickable button to the document body.

\paragraph{Run the JavaScript}

To display the output in a browser, create an HTML-document called \ic{index.html} and open it.

\lang{xml}\begin{lstlisting}
<!DOCTYPE html>
<html>
	<body>
		<script src="main-javascript.js"></script>
	</body>
</html>
\end{lstlisting}

\paragraph{More information}

\begin{itemize}
	\item \Fullref{debugging-javascript}
	\item \href{https://code.haxe.org/category/javascript/}{Haxe/JavaScript tutorials}
	\item \href{https://api.haxe.org/js/}{Haxe JavaScript API docs}
	\item \href{https://developer.mozilla.org/bm/docs/Web/JavaScript}{MDN JavaScript Reference}
	\item \href{https://matthijskamstra.github.io/haxejs/}{Haxe/Javascript documentation by Matthijs Kamstra}
\end{itemize}

\subsection{ECMAScript 6 class generation}
\label{target-javascript-es6}

\since{4.0}

Starting with Haxe 4.0, Haxe can generate \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes}{ES6 class definitions} instead of classic function + prototype combination. This might be required when using third-party ES6 libraries, because native ES6 classes cannot be extended using the old method.

To enable ES6 generation mode, simply add \ic{-D js-es=6} to the compiler arguments.

\paragraph{Accessing this before calling super constructors}

One of significant differences between Haxe classes and ES6 classes reveals itself when inheritance is used. ES6 does not allow accessing \ic{this} in any way before calling \expr{super()} within a child class constructor, while Haxe allows calling \ic{super()} at any place in the constructor.

Even when we don't explicitly access \expr{this} before \expr{super()} in Haxe code, it can still happen when a class has fields with initializer values.

Let's take a look at the following example:

\lang{haxe}\begin{lstlisting}
class Base {
  function new() {
    init();
  }
  function init() {
    trace("base init");
  }
}

class Child extends Base {
  var field = "hello";

  override function init() {
    trace(field);
  }
}
\end{lstlisting}

Haxe guarantees that the fields will be initialized before any constructor code is executed, and because accessing \expr{this} (for setting the field value) before the \expr{super()} call is not allowed in ES6, Haxe has to work this limitation around by transforming constructors like in the following example:

\lang{js}\begin{lstlisting}
class Base {
  constructor() {
    if(Base._hx_skip_constructor) {
      return;
    }
    this._hx_constructor();
  }
  _hx_constructor() {
    this.init();
  }
  init() {
    console.log("src/Main.hx:6:","base init");
  }
}
class Child extends Base {
  constructor() {
    Base._hx_skip_constructor = true;
    super();
    Base._hx_skip_constructor = false;
    this._hx_constructor();
  }
  _hx_constructor() {
    this.field = "hello";
    super._hx_constructor();
  }
  init() {
    console.log("src/Main.hx:14:",this.field);
  }
}
Base._hx_skip_constructor = false;
\end{lstlisting}

Note that the compiler does its best to be smart and only generates this workaround code when it's required.

\paragraph{When extending extern classes with constructors}

One important limitation that one has to keep in mind is that it's obviously not possible for Haxe to do these transformations on \href{https://haxe.org/manual/lf-externs.html}{extern} class implementations. That's why it is impossible to access \expr{this} before calling \expr{super()} at all when extending a native \expr{extern} class. Haxe will detect these cases and emit a compile error pointing to first expression or field declaration that requires \expr{this} access.

For example:

\lang{haxe}\begin{lstlisting}
extern class Base {
  function new();
}

class Child extends Base {
  var field = "hello";
}
\end{lstlisting}

Trying to compile this will fail with the following error: \ic{Main.hx:6: characters 3-23 : Must call super() constructor before accessing this in classes derived from an extern class with constructor}

However, if the parent \expr{extern} class would not have a constructor defined, this code would compile, because the compiler knows that it is safe to call a parent's empty \expr{super()} constructor before anything else.

So, the following code:

\lang{haxe}\begin{lstlisting}
extern class Base {
}

class Child extends Base {
  var field = "hello";
}
\end{lstlisting}

Will generate the expected ES6 output:

\lang{js}\begin{lstlisting}
class Child extends Base {
  constructor() {
    super();
    this.field = "hello";
  }
}
\end{lstlisting}

\subsection{Using external JavaScript libraries}
\label{target-javascript-external-libraries}

The \tref{externs mechanism}{lf-externs} provides access to the native APIs in a type-safe manner. It assumes that the defined types exist at run-time but assumes nothing about how and where those types are defined. 

An example of an extern class is the \href{https://github.com/HaxeFoundation/haxe/blob/development/std/js/jquery/JQuery.hx}{jQuery class} of the Haxe Standard Library. 
To illustrate, here is a simplified version of this extern class:

\begin{lstlisting}
package js.jquery;
@:native("$") extern class JQuery {
	/**
		Creates DOM elements on the fly from the provided string of raw HTML.
		OR
		Accepts a string containing a CSS selector which is then used to match a set of elements.
		OR
		Binds a function to be executed when the DOM has finished loading.
	**/
	@:selfCall
	@:overload(function(element:js.html.Element):Void { })
	@:overload(function(selection:js.jquery.JQuery):Void { })
	@:overload(function(callback:haxe.Constraints.Function):Void { })
	@:overload(function(selector:String, ?context:haxe.extern.EitherType<js.html.Element, js.jquery.JQuery>):Void { })
	public function new():Void;

	/**
		Adds the specified class(es) to each element in the set of matched elements.
	**/
	@:overload(function(_function:Int -> String -> String):js.jquery.JQuery { })
	public function addClass(className:String):js.jquery.JQuery;

	/**
		Get the HTML contents of the first element in the set of matched elements.
		OR
		Set the HTML contents of each element in the set of matched elements.
	**/
	@:overload(function(htmlString:String):js.jquery.JQuery { })
	@:overload(function(_function:Int -> String -> String):js.jquery.JQuery { })
	public function html():String;
}
\end{lstlisting}

Note that functions can be overloaded to accept different types of arguments and return values, using the \expr{@:overload} metadata. Function overloading works only in externs.

Using this extern, we can use jQuery like this:

\begin{lstlisting}
import js.jquery.*;
..
new JQuery("#my-div").addClass("brand-success").html("haxe is great!");
..
\end{lstlisting}

The package and class name of the extern class should be the same as defined in the external library. If that is not the case, rewrite the path of a class using \expr{@:native}.

\begin{lstlisting}
package my.application.media;

@:native('external.library.media.video')
extern class Video {
..
\end{lstlisting}

Some JavaScript libraries favor instantiating classes without using the \expr{new} keyword. To prevent the Haxe compiler outputting the \expr{new} keyword when using a class, we can attach a \expr{@:selfCall} metadata to its constructor. For example, when we instantiate the jQuery extern class above, \expr{new JQuery()} will be outputted as \expr{\$()} instead of \expr{new \$()}. The \expr{@:selfCall} metadata can also be attached to a method. In this case, the method will be interpreted as a direct call to the object, illustrated as follows:

\begin{lstlisting}
extern class Functor {
	public function new():Void;
	@:selfCall function call():Void;
}

class Test {
	static function main() {
		var f = new Functor();
		f.call(); // will be outputted as `f();`
	}
}
\end{lstlisting}

Beside externs, \tref{Typedefs}{type-system-typedef} can be another great way to name (or alias) a JavaScript type. The major difference between typedefs and externs is that, typedefs are duck-typed but externs are not. Typedefs are suitable for common data structures, e.g. point (\expr{\{x:Float, y:Float\}}). Use of a point structure typedef for function arguments allows external JavaScript functions to accept point class instances from Haxe or from another JavaScript library. It is also useful for typing JSON objects.

The Haxe Standard Library comes with externs of \href{https://jquery.com/}{jQuery} and \href{http://blog.deconcept.com/swfobject/}{SWFObject}. Their version compatibility is summarized as follows:

\begin{center}
\begin{tabular}{| l | l | l |}
	\hline
	Haxe version & Library               & Externs location \\ \hline
	3.3          & jQuery 1.12.1 / 2.2.1 & <code>js.jquery.*</code> \\
	3.2-         & jQuery 1.6.4          & <code>js.JQuery</code> \\
	3.3          & SWFObject 2.3         & <code>js.swfobject.*</code> \\
	3.2-         & SWFObject 1.5         & <code>js.SWFObject</code> \\ \hline
\end{tabular}
\end{center}

There are many externs for other popular native libraries available on \tref{Haxelib library}{haxelib}. To view a list of them, check out the \href{http://lib.haxe.org/t/extern/}{extern tag}.

\subsection{JavaScript target Metadata}
\label{target-javascript-metadata}

This is the list of JavaScript specific metadata. For more information, see also the complete list of all \tref{Haxe built-in metadata}{cr-metadata}.

\begin{center}
\begin{tabular}{| l | l |}
	\hline
	\multicolumn{2}{|c|}{JavaScript metadata} \\ \hline
	Metadata &  Description \\ \hline
	@:expose \_(?Name=Class path)\_  &  Makes the class available on the \expr{window} object or \expr{exports} for node.js  \\
	@:jsRequire  &  Generate javascript module require expression for given extern \\
	@:selfCall  &  Translates method calls into calling object directly \\
\end{tabular}
\end{center}

\subsection{Exposing Haxe classes for JavaScript}
\label{target-javascript-expose}

It is possible to make Haxe classes or static fields available for usage in plain JavaScript. 
To expose, add the \expr{@:expose} metadata to the desired class or static fields.

This example exposes the Haxe class \ic{MyClass}.

\haxe{assets/ClassExpose.hx}

It generates the following JavaScript output:

\lang{js}\begin{lstlisting}
(function ($hx_exports) { "use strict";
var MyClass = $hx_exports.MyClass = function(name) {
	this.name = name;
};
MyClass.prototype = {
	foo: function() {
		return "Greetings from " + this.name + "!";
	}
};
})(typeof window != "undefined" ? window : exports);
\end{lstlisting}

By passing globals (like \ic{window} or \ic{exports}) as parameters to our anonymous function in the JavaScript module, it becomes available which allows to expose the Haxe generated module.

In plain JavaScript it is now possible to create an instance of the class and call its public functions.

\lang{js}\begin{lstlisting}
// JavaScript code
var instance = new MyClass('Mark');
console.log(instance.foo()); // logs a message in the console
\end{lstlisting}

The package path of the Haxe class will be completely exposed. To rename the class or define a different package for the exposed class, use \expr{@:expose("my.package.MyExternalClass")}

\paragraph{Shallow expose}

When the code generated by Haxe is part of a larger JavaScript project and wrapped in a large closure it is not always necessary to expose the Haxe types to global variables.
Compiling the project using \ic{-D shallow-expose} allows the types or static fields to be available for the surrounding scope of the generated closure only.

When the code is compiled using \ic{-D shallow-expose}, the generated output will look like this:

\lang{js}\begin{lstlisting}
var $hx_exports = $hx_exports || {};
(function () { "use strict";
var MyClass = $hx_exports.MyClass = function(name) {
	this.name = name;
};
MyClass.prototype = {
	foo: function() {
		return "Greetings from " + this.name + "!";
	}
};
})();
var MyClass = $hx_exports.MyClass;
\end{lstlisting}

In this pattern, a var statement is used to expose the module; it doesn't write to the \ic{window} or \ic{exports} object. 

\subsection{Loading extern classes using ``require'' function}
\label{target-javascript-require}
\since{3.2.0}

Modern \target{JavaScript} platforms, such as Node.js provide a way of loading objects
from external modules using the ``require'' function. Haxe supports automatic generation
of ``require'' statements for \expr{extern} classes.

This feature can be enabled by specifying \expr{@:jsRequire} metadata for the extern class. If our \expr{extern} class represents a whole module, we pass a single argument to the \expr{@:jsRequire} metadata specifying the name of the module to load:

\haxe{assets/JSRequireModule.hx}

In case our \expr{extern} class represents an object within a module, second \expr{@:jsRequire} argument specifies an object to load from a module:

\haxe{assets/JSRequireObject.hx}

The second argument is a dotted-path, so we can load sub-objects in any hierarchy.

If we need to load custom JavaScript objects in runtime, a \expr{js.Lib.require} function can be used. It takes \expr{String} as its only argument and returns \expr{Dynamic}, so it is advised to be assigned to a strictly typed variable.

\section{Flash}
\label{target-flash}
\state{NoContent}

\subsection{Getting started with Haxe/Flash}
\label{target-flash-getting-started}

Developing Flash applications is really easy with Haxe. Let's look at our first code sample.
This is a basic example showing most of the toolchain. 

Create a new folder and save this class as \ic{Main.hx}.

\begin{lstlisting}
import flash.Lib;
import flash.display.Shape;
class Main {
    static function main() {
        var stage = Lib.current.stage;
        
        // create a center aligned rounded gray square
        var shape = new Shape();
        shape.graphics.beginFill(0x333333);
		shape.graphics.drawRoundRect(0, 0, 100, 100, 10);
		shape.x = (stage.stageWidth - 100) / 2;
		shape.y = (stage.stageHeight - 100) / 2;
		
		stage.addChild(shape);
    }    
}
\end{lstlisting}

To compile this, either run the following from the command line:

\lang{hxml}\begin{lstlisting}
haxe --swf main-flash.swf --main Main --swf-version 15 --swf-header 960:640:60:f68712
\end{lstlisting}

Another possibility is to create and run (double-click) a file called \ic{compile.hxml}. In this example the hxml file should be in the same directory as the example class.

\lang{hxml}\begin{lstlisting}
--swf main-flash.swf
--main Main
--swf-version 15
--swf-header 960:640:60:f68712
\end{lstlisting}

The output will be a main-flash.swf with size 960x640 pixels at 60 FPS with an orange background color and a gray square in the center.

\paragraph{Display the Flash}

Run the SWF standalone using the \href{https://www.adobe.com/support/flashplayer/downloads.html}{Standalone Debugger FlashPlayer}. 

To display the output in a browser using the Flash plugin, create an HTML-document called \ic{index.html} and open it.

\lang{xml}\begin{lstlisting}
<!DOCTYPE html>
<html>
	<body>
		<embed src="main-flash.swf" width="960" height="640">
	</body>
</html>
\end{lstlisting}

\paragraph{More information}

\begin{itemize}
	\item \href{https://api.haxe.org/flash/}{Haxe/Flash API docs}
	\item \href{http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/}{Adobe Livedocs}
\end{itemize}

\subsection{Embedding resources}
\label{target-flash-resources}

Embedding resources is different in Haxe compared to ActionScript 3. Instead of using \ic{\[embed\]} (AS3-metadata) use \tref{Flash specific compiler metadata}{target-flash-metadata} like \ic{@:bitmap}, \ic{@:font}, \ic{@:sound} or \ic{@:file}.

\begin{lstlisting}
import flash.Lib;
import flash.display.BitmapData;
import flash.display.Bitmap;

class Main {
  public static function main() {
    var img = new Bitmap( new MyBitmapData(0, 0) );
    Lib.current.addChild(img);
  }
}

@:bitmap("relative/path/to/myfile.png") 
class MyBitmapData extends BitmapData { }
\end{lstlisting}

\subsection{Using external Flash libraries}
\label{target-flash-external-libraries}

To embed external \ic{.swf} or \ic{.swc} libraries, use the following \href{https://haxe.org/documentation/introduction/compiler-usage.html}{compilation options}:

\begin{description}
	\item[\expr{--swf-lib <file>}] Embeds the SWF library in the compiled SWF.
	\item[\expr{--swf-lib-extern <file>}] Adds the SWF library for type checking but doesn't include it in the compiled SWF.
\end{description}

The standard compilation options also provide more Haxe sources to be added to the project:

\begin{itemize}
	\item To add another class path use \expr{-p <directory>}.
	\item To add a \tref{Haxelib library}{haxelib} use \expr{-L <library-name>}.
	\item To force a whole package to be included in the project, use \expr{--macro include('mypackage')} which will include all the classes declared in the given package and subpackages. 
\end{itemize}

\subsection{Flash target Metadata}
\label{target-flash-metadata}

This is the list of Flash specific metadata. For a complete list see \tref{Haxe built-in metadata}{cr-metadata}.

\begin{center}
\begin{tabular}{| l | l |}
	\hline
	\multicolumn{2}{|c|}{Flash metadata} \\ \hline
	Metadata &  Description  \\ \hline
	@:bind  &  Override Swf class declaration \\
	@:bitmap \_(Bitmap file path)\_  &  \_Embeds given bitmap data into the class (must extend \expr{flash.display.BitmapData}) \\
	@:debug  &  Forces debug information to be generated into the Swf even without \expr{--debug} \\
	@:file(File path)  &  Includes a given binary file into the target Swf and associates it with the class (must extend \expr{flash.utils.ByteArray}) \\
	@:font \_(TTF path Range String)\_  &  Embeds the given TrueType font into the class (must extend \expr{flash.text.Font}) \\
	@:getter \_(Class field name)\_  &  Generates a native getter function on the given field  \\
	@:noDebug &  Does not generate debug information into the Swf even if \expr{--debug} is set \\
	@:ns  &  Internally used by the Swf generator to handle namespaces \\
	@:setter \_(Class field name)\_  &  Generates a native setter function on the given field \\
	@:sound \_(File path)\_  &  Includes a given \_.wav\_ or \_.mp3\_ file into the target Swf and associates it with the class (must extend \expr{flash.media.Sound}) \\
\end{tabular}
\end{center}

\section{Neko}
\label{target-neko}

\section{PHP}
\label{target-php}
\state{NoContent}

\subsection{Getting started with Haxe/PHP}
\label{target-php-getting-started}

To get started with Haxe/PHP, create a new folder and save this class as \ic{Main.hx}.

\haxe{assets/HelloPHP.hx}

To compile, either run the following from the command line:

\lang{hxml}\begin{lstlisting}
haxe --php bin --main Main
\end{lstlisting}

Another possibility is to create and run (double-click) a file called \ic{compile.hxml}. In this example the hxml file should be in the same directory as the example class.

\lang{hxml}\begin{lstlisting}
--php bin
--main Main
\end{lstlisting}

The compiler outputs in the given \emph{bin}-folder, which contains the generated PHP classes that prints the traced message when you run it.

\since{4.0.0}

The generated PHP code is compatible with PHP 7.0.0 or later. Prior to Haxe 4, the minimum required version was PHP 5.1.0.

\paragraph{More information}

\begin{itemize}
	\item \href{https://api.haxe.org/php/}{Haxe/PHP API docs}
	\item \href{http://php.net/docs.php}{PHP.net Documentation}
	\item \href{http://phptohaxe.haqteam.com/code.php}{PHP to Haxe tool}
\end{itemize}


\section{C++}
\label{target-cpp}
\state{NoContent}

\subsection{Getting started with Haxe/C++}
\label{target-cpp-getting-started}
The c++ target uses various c++ compilers, which are assumed to be already installed on the system, to create native executables or libraries.  The compilation happens in two phases.  Firstly, the Haxe compiler generates source, header and build files in an output directory.  Secondly, the "hxcpp" \tref{Haxelib library}{haxelib} is invoked to run the system compilers and linkers required to generate the ultimate result.

\paragraph{Prerequisites}
Before you can use the C++ target, you need in install
\begin{itemize}
	\item hxcpp, e.g. \ic{haxelib install hxcpp}.
	\item A system or cross-compiler
\end{itemize}

\paragraph{System Compilers}
System compilers are supported on the three primary operating systems - Mac, Linux, and Windows.  On Mac, it is recommended that you install the latest Xcode from the Mac App Store.  On Linux, it is recommended that you use the system package manager to install the compilers and on Windows, Microsoft Visual Studio is recommended.  On Windows, you can also use gcc-based compilers.  A minimal distribution is included in a \tref{Haxelib library}{haxelib}, and can be installed with \ic{haxelib install minimingw}.

\paragraph{Cross Compilers}
Hxcpp can be used to compile for non-host architectures if you have a suitable cross-compiler installed.  The compilers are usually supplied in the form of a Software Development Kits (SDK), or in the case of iOS devices, come with the system compiler (Xcode).  Selecting which compiler to use is achieved by defining particular variables in the hxcpp build environment.  Note that the hxcpp build tool is only responsible for producing a native executable or a native library (static or dynamic), not the complete bundling and packaging of assets and meta-data that is typically required for mobile devices.  Additional Haxe libraries can be used for this task.

\begin{itemize}
	\item \href{https://api.haxe.org/cpp/}{Haxe/C++ API docs}
\end{itemize}

\subsection{The Hxcpp Build Environment}
\label{target-cpp-build-environment}
The hxcpp build environment can be controlled by setting, or defining, variables in key-value pairs. Defining a key without a particular value is usually enough to trigger the desired behaviour, and these keys are often referred to as "defines".

\paragraph{Defining From the Command Line}
The easiest way to change the hxcpp build environment is to pass the defines though the Haxe command line using \ic{-D}.  Key-value pairs can also be passed this way, e.g.:

\ic{ haxe --main Main --cpp cpp -D android -D static_link -D PLATFORM=android-9 }

Here, \ic{android} is defined - this causes hxcpp to cross-compile to android, \ic{static_link} is defined, which causes a static (rather than dynamic) library to be created and the android target platform is set to a particular value.  This platform information is passed on to the SDK so it can generate the appropriate code.

Advanced users can add additional defines to the system at compile time using macros.  These definitions will also be passed on to the hxcpp build tool.

\paragraph{Defining From the System Environment Variables}
The hxcpp build tool will import all the system environment variables, so you can configure the processes using the system like:

\ic{ setenv HXCPP_VERBOSE }

If you are running Haxe though an IDE, some care must be taken with environment variables since the variables may be read once from the environment in which the IDE was started, rather than changing when the variables are changed on the system.

\paragraph{Defining From .hxcpp_config.xml}
The hxcpp build tool parses several "build files".  These files are in a basic xml file format, and can be used to set, or conditionally set, configuration variables.  As part of the build process, the \ic{.hxcpp_config.xml} file, known as the configuration file, will be read (twice).  This file is located in the user's home directory (or user's profile directory on windows) and is the best place to configure variables that are specific to the system that rarely change, such as the location of the cross-compiler SDKs.  A placeholder file will be generated the first time hxcpp is run by a user on the machine.  You can see the exact location of this file in the build log if you compile with the \ic{HXCPP_VERBOSE} define.

The configuration file is read twice.  The first time the \ic{"vars"} section is read early in the configuration process, and is used to set up and configure the location of the compilers.  The second time, the \ic{"exes"} section is read near the end of the processes and allows modification of the compiler or build process based on all the available information.  See \Fullref{target-cpp-file-format} for details on the file format.

\paragraph{Defining Via @:buildXml Metadata}
Configuration data can be injected into the "build.xml" file that is created by Haxe.  This is done attaching metadata to a Haxe class that is directly or indirectly included in the build.  For example:
\begin{lstlisting}
@:buildXml("
<target id='haxe'>
  <lib name='${haxelib:nme}/lib/${BINDIR}/libnme${LIBEXTRA}${LIBEXT}'/>
</target>
<include name='${haxelib:nme}/lib/NmeLink.xml'/>
")
@:keep class StaticNme
{
  ...
\end{lstlisting}

This metadata is best for adding libraries or include paths to the build.
Some notes:
\begin{itemize}
	\item The @:keep metadata is added to prevent dead-code-elimination from removing this class
	\item Quoting can be a bit tricky - here the double-quotes are used for Haxe, and the single quotes are added to the build.xml.
	\item Injecting a single "include" command is a good way to manage the quoting issue.
	\item Knowledge of the build system is required to get this right. See \Fullref{target-cpp-file-format} for details on the file format.
	\item The build.xml file is read after the choice of compiler has been made, so it is generally not suitable for configuring the compiler.
\end{itemize}


\subsection{build.xml File Format}
\label{target-cpp-file-format}
The build.xml file format is designed to address the very specific goal of generating compiled output as fast as possible on a wide variety of compilers.  Therefore, at its core, it is simply a list of files to compile, and their dependencies, and a list of compiler exes and flags required to get the job done.  Conditional variable setting is added to support the great variety of compilers and use cases encountered by hxcpp.  However, much of the logic required to orchestrate the compiler sequences, such as precompiling headers, is defined in Haxe and implemented in the build tool itself, rather than being scriptable.

A hxcpp build file consists of a series of commands and data structures in xml format.  The commands are executed immediately as they are encountered, while the data structures are accumulated and used after all the build files have been parsed.

\paragraph{Running a build.xml File With Hxcpp}
When you compile a Haxe program with hxcpp, the Haxe compiler will normally run the hxcpp build tool on the generated build.xml file automatically.  You can, however, prevent this by adding \ic{-D no-compilation} to the Haxe command line.

You can run the hxcpp build tool on your own build files using

\ic{haxelib run hxcpp myfile.xml [-Ddefine] [-Dkey=value]}

Note the lack of space between the "-D" and the variable name.

A minimal build.xml file consists of an xml container and a dummy default target, like:
\lang{xml}\begin{lstlisting}
<xml>
   <echo value="Hello!" />
   <target id="default" />
</xml>
\end{lstlisting}

\paragraph{Conditions, Substitutions and Sections}
Most elements in the hxcpp xml file allow a common syntax for dynamic configuration.

Xml elements can contain conditional "if" and/or "unless" values.  These conditions are evaluated at parse time and the entire element will be skipped if the condition fails.  For example adding this lines:
\lang{xml}\begin{lstlisting}
<xml>
  <echo value="Hello A" if="A" />
  <echo value="Hello A && B" if="A B" />
  <echo value="Hello A || B" if="A || B" />
  <echo value="Hello !A" unless="A" />
  <echo value="Hello !(A && B)" unless="A B" />
  <echo value="Hello !(A || B)" unless="A || B" />
  <echo value="Never Never" if="A" unless="A" />
  <target id="default" />
</xml>
\end{lstlisting}

and running:

\ic{haxelib run hxcpp myfile.xml -DA}

shows how the logic depends on whether or not A or B has been defined.

Sections can be used to group commands together based on a common condition.  They can also be used to include only part of another xml file, but this technique is currently only used when parsing the .hxcpp_config.xml file.  For example:

\lang{xml}\begin{lstlisting}
  <section if="C" >
    <echo value="I See" />
    <echo value="You" />
  </section>
\end{lstlisting}

The xml attribute values can be substituted with variable values using dollars-brace syntax.  Using a colon allows a function-call to be substituted, e.g.:

\lang{xml}\begin{lstlisting}
  <echo value="some var = ${SOME_VAR}" />
  <echo value="${haxelib:hxcpp}/include" />
\end{lstlisting}

\subsection{Using C++ Defines}
\label{target-cpp-defines}
\begin{itemize}
	\item ANDROID_HOST
	\item ANDROID_NDK_DIR
	\item ANDROID_NDK_ROOT
	\item BINDIR
	\item DEVELOPER_DIR
	\item HXCPP
	\item HXCPP_32
	\item HXCPP_COMPILE_CACHE
	\item HXCPP_COMPILE_THREADS
	\item HXCPP_CONFIG
	\item HXCPP_CYGWIN
	\item HXCPP_DEPENDS_OK
	\item HXCPP_EXIT_ON_ERROR
	\item HXCPP_FORCE_PDB_SERVER
	\item HXCPP_M32
	\item HXCPP_M64
	\item HXCPP_ARMV6
	\item HXCPP_ARMV7
	\item HXCPP_ARMV7S
	\item HXCPP_ARM64
	\item HXCPP_X86
	\item HXCPP_MINGW
	\item HXCPP_MSVC
	\item HXCPP_MSVC_CUSTOM
	\item HXCPP_MSVC_VER
	\item HXCPP_NO_COLOR
	\item HXCPP_NO_COLOUR
	\item HXCPP_VERBOSE
	\item HXCPP_WINXP_COMPAT
	\item HXCPP_API_LEVEL
	\item HXCPP_DEBUG_LINK
	\item DHXCPP_STACK_TRACE
	\item HXCPP_STACK_LINE
	\item HXCPP_CHECK_POINTER
	\item HXCPP_DEBUGGER
	\item HXCPP_CPP11
	\item HXCPP_STRICT_CASTS
	\item HXCPP_VISIT_ALLOCS
	\item HXCPP_WINXP_COMPAT
	\item HXCPP_OPTIMIZE_FOR_SIZE
	\item HXCPP_GC_MOVING
	\item IPHONE_VER
	\item LEGACY_MACOSX_SDK
	\item LEGACY_XCODE_LOCATION
	\item MACOSX_VER
	\item MSVC_VER
	\item NDKV
	\item NO_AUTO_MSVC
	\item PLATFORM
	\item QNX_HOST
	\item QNX_TARGET
	\item TOOLCHAIN_VERSION
	\item USE_GCC_FILETYPES
	\item USE_PRECOMPILED_HEADERS
	\item android
	\item apple
	\item blackberry
	\item cygwin
	\item dll_import
	\item dll_import_include
	\item dll_import_link
	\item emcc
	\item emscripten
	\item gph
	\item hardfp
	\item haxe_ver
	\item ios
	\item iphone
	\item iphoneos
	\item iphonesim
	\item linux
	\item linux_host
	\item mac_host
	\item macos
	\item mingw
	\item rpi
	\item simulator
	\item tizen
	\item toolchain
	\item webos
	\item windows
	\item windows_host
	\item winrt
	\item xcompile
\end{itemize}

\subsection{Using C++ Pointers}
\label{target-cpp-pointers}


\section{Cppia}
\label{target-cppia}
\state{NoContent}


\subsection{Getting started with Haxe/Cppia}
\label{target-cppia-getting-started}

Cppia is a scriptable cpp subtarget for Haxe. A cppia script is an instructions assembly script that can be run inside a cppia host and gives you runtime speed at near-zero compilation time. It also lets you add performance critical code to the host, which gives you full cpp runtime speed for those parts.

\paragraph{More information}
\begin{itemize}
	\item \href{https://api.haxe.org/cpp/cppia/index.html}{Cppia API documentation}
	\item \href{https://code.haxe.org/category/other/working-with-cppia/index.html}{Cppia tutorial}
\end{itemize}

\section{Java}
\label{target-java}
\state{NoContent}

\subsection{Getting started with Haxe/Java}
\label{target-java-getting-started}

To get started with Haxe/Java, create a new folder and save this class as \ic{Main.hx}.

\haxe{assets/HelloWorld.hx}

To compile Haxe to Java we need two obvious prerequisites installed:

\begin{itemize}
	\item \href{http://lib.haxe.org/p/hxjava}{hxjava haxelib}. This is the support library for the Java backend of the Haxe compiler.
	\item \href{https://java.com/download/}{JRE - Java Runtime Environment}.
\end{itemize}

Run the following from the command line:

\lang{hxml}\begin{lstlisting}
haxe --java bin --main Main
\end{lstlisting}

Another possibility is to create and run (double-click) a file called \ic{compile.hxml}. In this example the hxml-file should be in the same directory as the example class.

\lang{hxml}\begin{lstlisting}
--java bin
--main Main
\end{lstlisting}

The compiler outputs in the given \emph{bin}-folder, which contains the generated sources / .jar files which prints the traced message when you execute it. 

To execute, run the following command:

\lang{sh}\begin{lstlisting}
java -jar bin/Main.jar
\end{lstlisting}

\paragraph{More information}

\begin{itemize}
	\item \href{https://api.haxe.org/java/}{Haxe/Java API docs}
	\item \href{https://docs.oracle.com/javase/}{Java Platform Documentation}
\end{itemize}


\section{C\#}
\label{target-cs}
\state{NoContent}

\subsection{Getting started with Haxe/C\#}
\label{target-cs-getting-started}

Haxe can be used as a language for .NET platform through its C\# target. Let's make a simple program using .NET Console class:

\haxe{assets/HelloWorld.hx}

To compile Haxe to C\# we need two obvious prerequisites installed:

\begin{itemize}
	\item \href{http://lib.haxe.org/p/hxcs}{hxcs haxelib}. This is the support library for the C\# backend of the Haxe compiler.
	\item \href{https://www.microsoft.com/net}{.NET development framework (either Microsoft.NET or Mono)}
\end{itemize}

After that we can compile to C\# using the \ic{--cs} option from either the command line or an hxml-file:

\lang{hxml}\begin{lstlisting}
haxe --cs out --main Main
\end{lstlisting}

The compiler will output C\# sources into  \emph{out/src} folder, then call C\# compiler to build  \emph{Main.exe} file into  \emph{out/bin} folder.

\paragraph{More information}

\begin{itemize}
	\item \href{https://api.haxe.org/cs/}{Haxe/C\# API docs}
	\item \href{https://msdn.microsoft.com/en-us/library/kx37x362.aspx}{C\# Documentation}
\end{itemize}


\subsection{.NET version and external libraries}
\label{target-cs-external-libraries}

By default, Haxe uses basic .NET 2.0 API provided by hxcs library (it ships mscorlib.dll and System.dll from the Mono project). We can specify different .NET version by providing \ic{-D net-ver=xx} define, where xx is major and minor digits of .NET version number, i.e. \ic{-D net-ver=40} for setting .NET version to 4.0. Note that currently, hxcs library only ships DLL files for .NET 2.0 and 4.0.

\paragraph{Using custom .NET distribution}

We can make Haxe use a custom set of DLL files as standard .NET framework. To do that, we need to first learn about how Haxe finds standard .NET libraries. Haxe/C\# looks for .DLL files in a directory path, constructed from three components:

\begin{itemize}
	\item .NET version (set by \ic{-D net-ver=xx}, defaults to \ic{20} as described above)
	\item .NET target (by default set to \ic{net}, but could be changed using \ic{-D net-target=xxx}, where \ic{xxx} could be \ic{micro}, \ic{compact} or some other).
	\item .NET std path (set by \ic{--net-std} option, by default points to netlib directory inside hxcs library)
\end{itemize}

The resulting search path will be \ic{<net_std_path>/<net_target>-<net_ver>/}, taking in the consideration default values described above, without any specific configuration haxe will load all .NET DLL files found in \ic{<hxcs_install_path>/netlib/net-20/}.

Now if we provide the following options:

\lang{hxml}\begin{lstlisting}
-D net-target=micro -D net-ver=35 --net-std=/dotnet
\end{lstlisting}

Haxe will load all .NET DLL files found in \ic{/dotnet/micro-35/}.


\paragraph{Using external libraries}

Haxe can directly load .NET assembly files (.DLL) and convert its type definitions for use as Haxe types. To load a .NET assembly, use \ic{--net-lib library.dll} compiler option. Haxe will then automatically parse types defined in that assembly file and make them available for import as Haxe types.

Some changes are performed to type naming of C\# classes to make them fit into Haxe type system, namely:

\begin{itemize}
	\item Namespaces are lowercased to follow Haxe package naming rules, so i.e. \ic{UnityEngine} becomes \ic{unityengine} (note that \ic{System} namespace is also prefixed with \ic{cs}, so  \ic{System.Core} becomes  \ic{cs.system.core})
	\item Inner classes are generated as \ic{OuterClassName_InnerClassName} and placed into the \ic{OuterClassName} module. So for example for an inner class \ic{B} inside a class \ic{A} inside a namespace \ic{Something}, the full Haxe type path will be \ic{something.A.A_B}. Note however, that if you do \ic{import something.A}, both \ic{A} and \ic{A_B} class will be available within your module as per standard Haxe import mechanism.
	\item Classes with type parameters have numbers of type params appended to their name, for example \ic{Dictionary<K,V>} becomes \ic{Dictionary_2<K,V>}
\end{itemize}


\subsection{Haxe/C\# Defines}
\label{target-cs-defines}

Besides \ic{-D net-ver} and \ic{-D net-target}:

\begin{itemize}
	\item \ic{-D dll} compile to a .NET assembly instead of an executable file. Added automatically when no \ic{--main} is specified.
	\item \ic{-D real-position} don't generate \#line directives that map C\# expression positions to original .hx files. Useful for tracking down issues related to code generation.
	\item \ic{-D no-root} generate package-less haxe types in the haxe.root namespace to avoid conflicts with other types in the root namespace
	\item \ic{-D erase-generics} fully erase type parameters from generated C\# files and generate non-generic classes. This is useful in some cases, like working with .NET Micro Framework or preventing generics-related issues with Unity3D AOT compiler.
	\item \ic{-D no-compilation} only generate C\# sources and don't invoke C\# compiler on them.
	\item \ic{-D keep-old-output} by default haxe cleans up stale generated source files from the output directory. This define disables that behaviour.
	\item \ic{-D dll-import}
\end{itemize}
	
Haxe automatically adds \ic{NET_xx} defines where xx is major and minor version numbers .NET versions up to selected one. For example, when using .NET 4.0 (by providing \ic{-D net-ver=40}), we have the following defines set automatically: \ic{NET_20}, \ic{NET_21}, \ic{NET_30}, \ic{ NET_35} and \ic{NET_40}. If we had \ic{-D net-ver=30}, we would only have \ic{NET_20}, \ic{NET_21} and \ic{NET_30}.

\subsection{Haxe/C\# Metadata}
\label{target-cs-metadata}

This is the list of C\# specific metadata. For more information, see also the complete list of all \tref{Haxe built-in metadata}{cr-metadata}.

\begin{center}
\begin{tabular}{| l | l | l |}
	\hline
	\multicolumn{3}{|c|}{JavaScript metadata} \\ \hline
	Metadata & Usage & Description \\ \hline
	@:nativeGen  &  on classes & don't generate reflection, generate proper type parameters. This is useful for some sort of interop, but slows down reflection and structural typing \\
	@:nativeGen  &  on "flat" enums & generate C\# enum, but note that C\# enums are not-nullable unlike haxe enums, so using null will be generated as a default enum value (0-indexed constructor). \\
	@:property  &  on non-physical fields (those with get/set/never accessors) & generate native C\# properties. useful for implementing extern interfaces or providing API for use from C\# \\
	@:event  &  on variables & generate an event delegate (this also requires pairing add_EventName, remove_EventName methods with relevant signatures \\
	@:protected  &  on a field & mark field as protected instead of public (could affect reflection, but useful for hiding fields when providing API for use from outside Haxe) \\
	@:struct  &  on classes  &  generate struct instead of class \\
\end{tabular}
\end{center}

\subsection{Injecting raw C\# code}
\label{target-cs-code-injection}

\paragraph{Class code injection}

TODO: @:classCode

\paragraph{Function code injection}

We can use \expr{@:functionCode} metadata for a method to generate raw C\# code inside a method body. It completely replaces any haxe expressions in method body. For example:

\begin{lstlisting}
@:functionCode("return (v is int);")
function isInt(v:Dynamic):Bool {
    return false;
}
\end{lstlisting}

Which will generate:

\begin{lstlisting}
public virtual bool isInt(object v) {
    return (v is int);
}
\end{lstlisting}


\section{Python}
\label{target-python}



\section{Lua}
\label{target-lua}
\state{NoContent}

\subsection{Getting started with Haxe/Lua}
\label{target-lua-getting-started}

To get started with Haxe for Lua, it's necessary to pick a Lua version and install
dependencies.  All versions of Lua are supported, but may require different
libraries.  Lua 5.1, 5.2, 5.3, and LuaJIT 2.0 and 2.1 (beta) are supported.

Lua is a very lightweight language that ships with a much smaller  feature set
than Haxe.  In some cases (e.g. regex), it's necessary to install supplementary
libraries that are used to support basic Haxe functionality.

In order to cover all dependencies, it is recommended to install and use
\href{https://github.com/luarocks/luarocks/wiki/Download}{LuaRocks}.  However,
if you do not utilize relevant behavior (e.g. regex) on a given platform,
or if you are using an embedded Lua client, then it is not necessary to
install any packages for basic language functionality.

With LuaRocks, install the following packages:

\lang{sh}\begin{lstlisting}
luarocks install lrexlib-pcre
luarocks install environ
luarocks install luasocket
luarocks install luv
\end{lstlisting}

On Lua 5.1, install the bitops library:
\lang{sh}\begin{lstlisting}
luarocks install luabitop
\end{lstlisting}

On Lua 5.3, install the bit32 library instead:
\lang{sh}\begin{lstlisting}
luarocks install bit32
\end{lstlisting}

When developing for multiple Lua versions, it is recommended to use
the Python package \href{https://github.com/mpeterv/hererocks}{hererocks}.

With Lua installed, it is possible to write a simple command line application.

Create a new folder, and save this class as \ic{Main.hx}.

\begin{lstlisting}
class Main {
    static function main() {
        trace("hello world");
    }
}
\end{lstlisting}

To compile, run the following:
\lang{hxml}\begin{lstlisting}
haxe --lua out.lua --main Main
\end{lstlisting}

\paragraph{More information}
\begin{itemize}
	\item \href{https://www.lua.org/}{Lua Homepage}
	\item \href{http://luajit.org/}{LuaJIT Homepage}
\end{itemize}

\subsection{Using external Lua libraries}
\label{target-lua-external-libraries}

The \tref{extern functionality}{lf-externs} in Haxe provides a way of declaring type signatures
for native Lua libraries.

\subsection{Version flags}
\label{target-lua-flags}

The Lua target enables the following define flags for the Haxe complier:

\begin{description}
	\item[\expr{-D lua-ver}] Enable special features for a specific Lua version. Currently, this flag will enable extern methods that are specific to certain versions (e.g. table.pack in Lua > 5.2).
	\item[\expr{-D luajit}] Enable special features for LuaJIT.  Currently this flag will enable the \ic{jit} and \ic{ffi} module namespaces.
	\item[\expr{-D lua-vanilla}] Generate code lacking some functionality (e.g. UTF-8) but with no additional library dependencies.
\end{description}

\subsection{Multireturns}
\label{target-lua-multireturns}

Lua allows for multiple values to be returned from a given function.  Haxe
does not support this by default, but can allow extern definitions to reference
multireturn values through the \ic{@:multiReturn} metadata.

\begin{lstlisting}
class Main {
    static function main() {
        var strfind = NativeString.find("foobar", "bar");
        trace(strfind.begin);
        trace(strfind.end);
    }
}

@:native("string")
extern class NativeString {
	public static function find(str : String, target : String): StringFind;
}

@:multiReturn extern class StringFind {
	var begin : Int;
	var end : Int;
}
\end{lstlisting}

This example has three parts:

\begin{itemize}
	\item The extern class \ic{NativeString} which is an extern for the base \ic{string} library in Lua.
	\item The \ic{StringFind} class which is marked as \ic{@:multiReturn} that describes the return values.
	\item The Main class that invokes the string method as a simple example.
\end{itemize}

The multireturn behavior in Haxe is optimized based on usage.  If fields are
only accessed directly, the Haxe compiler will allocate the multireturn to
individual variables.  But, if you pass or assign the entire multireturn value,
the compiler will wrap all values into a table object.  This operation ensures
that multireturn variable handling only carries as much overhead as needed.



\section{HashLink}
\label{target-hl}
