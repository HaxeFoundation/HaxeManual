\chapter{Expressions}
\label{expression}

Expressions in Haxe define what a program \emph{does}. Most expressions are found in the body of a \tref{method}{class-field-method}, where they are combined to express what that method should do. This section explains the different kinds of expressions. Some definitions help here:

\define{Name}{define-name}{A general name may refer to
\begin{itemize}
	\item a type,
	\item a local variable,
	\item a local function or
	\item a field.
\end{itemize}}

\define{Identifier}{define-identifier}{Haxe identifiers start with an underscore \expr{_}, a dollar \expr{\$}, a lower-case character \expr{a-z} or an upper-case character \expr{A-Z}. After that, any combination and number of \expr{_}, \expr{A-Z}, \expr{a-z} and \expr{0-9} may follow.\\
Further limitations follow from the usage context, which are checked upon typing:
\begin{itemize}
	\item Type names must start with an upper-case letter \expr{A-Z} or an underscore \expr{_}.
	\item Leading dollars are not allowed for any kind of \tref{name}{define-name} (dollar-names are mostly used for \tref{macro reification}{macro-reification}).
\end{itemize}}

\since{3.3.0}

Haxe reserves the identifier prefix \expr{_hx_} for internal use. This is not enforced by the parser or typer.

\paragraph{Keywords}
\label{expression-keywords}

The following Haxe keywords may not be used as identifiers:

\begin{itemize}
	\item \expr{abstract}
	\item \expr{break}
	\item \expr{case}
	\item \expr{cast}
	\item \expr{catch}
	\item \expr{class}
	\item \expr{continue}
	\item \expr{default}
	\item \expr{do}
	\item \expr{dynamic}
	\item \expr{else}
	\item \expr{enum}
	\item \expr{extends}
	\item \expr{extern}
	\item \expr{false}
	\item \expr{final}
	\item \expr{for}
	\item \expr{function}
	\item \expr{if}
	\item \expr{implements}
	\item \expr{import}
	\item \expr{in}
	\item \expr{inline}
	\item \expr{interface}
	\item \expr{macro}
	\item \expr{new}
	\item \expr{null}
	\item \expr{operator}
	\item \expr{overload}
	\item \expr{override}
	\item \expr{package}
	\item \expr{private}
	\item \expr{public}
	\item \expr{return}
	\item \expr{static}
	\item \expr{switch}
	\item \expr{this}
	\item \expr{throw}
	\item \expr{true}
	\item \expr{try}
	\item \expr{typedef}
	\item \expr{untyped}
	\item \expr{using}
	\item \expr{var}
	\item \expr{while}
\end{itemize}


\paragraph{Related content}
\begin{itemize}
	\item Haxe Code Cookbook  article: \href{http://code.haxe.org/category/principles/everything-is-an-expression.html}{Everything is an expression}.
\end{itemize}


\section{Blocks}
\label{expression-block}

A block in Haxe starts with an opening curly brace \expr{\{} and ends with a closing curly brace \expr{\}}. A block may contain several expressions, each of which is followed by a semicolon \expr{;}. The general syntax is thus:

\begin{lstlisting}
{
	expr1;
	expr2;
	...
	exprN;
}
\end{lstlisting}
The value and by extension the type of a block-expression is equal to the value and the type of the last sub-expression.

Blocks can contain local variables declared by \tref{\expr{var} expression}{expression-var}, as well as local functions declared by \tref{\expr{function} expressions}{expression-function}. These are available within the block and within sub-blocks, but not outside the block. Also, they are available only after their declaration. The following example uses \expr{var}, but the same rules apply to \expr{function} usage:

\begin{lstlisting}
{
	a; // error, a is not declared yet
	var a = 1; // declare a
	a; // ok, a was declared
	{
		a; // ok, a is available in sub-blocks
	}
  // ok, a is still available after
	// sub-blocks	
	a;
}
a; // error, a is not available outside
\end{lstlisting}
At runtime, blocks are evaluated from top to bottom. Control flow (e.g. \tref{exceptions}{expression-try-catch} or \tref{return expressions}{expression-return}) may leave a block before all expressions
are evaluated.

\paragraph{Variable Shadowing}

Haxe allows local variable shadowing within the same block. This means that
a \expr{var}, \expr{final}, or \expr{function} can be declared with the same name that was previously available in a block, effectively hiding it from the further code:

\begin{lstlisting}
{
	var v = 42; // declare v
	$type(v); // Int
	var v = "hi"; // declare a new v
	$type(v); // String, previous declaration is not available
}
\end{lstlisting}

It might come as a surprise that this is allowed, but it's useful to avoid pollution of local name space and thus prevent accidental usage of a wrong variable.

Note, that the shadowing strictly follows syntax, so if a variable was captured
in a closure before it was shadowed, that closure would still reference the
original declaration:

\begin{lstlisting}
{
	var a = 1;
	function f() {
	    trace(a);
	}
	var a = 2;
	f(); // traces 1
}
\end{lstlisting}

\since{4.0.0}

It is possible that variable shadowing in code is unintentional. The compiler can be set to emit warnings about all instances of variable shadowing with the \expr{-D warn-var-shadowing} define.


\section{Constants}
\label{expression-constants}

The Haxe syntax supports the following constants:

\begin{description}
	\item[Int:] An \tref{integer}{define-int}, such as \expr{0}, \expr{1}, \expr{97121}, \expr{-12}, \expr{0xFF0000}.
	\item[Float:] A \tref{floating point number}{define-float}, such as \expr{0.0}, \expr{1.}, \expr{.3}, \expr{-93.2}.
	\item[String:] A \tref{string of characters}{define-string}, such as \expr{""}, \expr{"foo"}, \expr{'{'}}, \expr{'bar'}.
	\item[true,false:] A \tref{boolean}{define-bool} value.
	\item[~/haxe/i:] A \tref{regular expression}{std-regex} literal.
	\item[null:] The null value.
\end{description}

Furthermore, the internal syntax structure treats \tref{identifiers}{define-identifier} as constants, which may be relevant when working with \tref{macros}{macro}.


\section{Operators}
\label{expression-operators}

\subsection{Unary Operators}
\label{expression-operators-unops}

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Operator & Operation & Operand type & Position & Result type \\ \hline
	\expr{\textasciitilde} & bitwise negation & \type{Int} & prefix & \type{Int} \\
	\expr{!} & logical negation & \type{Bool} & prefix & \type{Bool} \\
	\expr{-} & arithmetic negation & \type{Float/Int} & prefix & same as operand \\
	\expr{++} & increment & \type{Float/Int} & prefix and postfix & same as operand \\
	\expr{--} & decrement & \type{Float/Int} & prefix and postfix & same as operand
\end{tabular}
\end{center}

\paragraph{Increment and decrement}

The increment and decrement operators change the given value, so they cannot be applied to a read-only value. They also produce different results based on whether they are used as a prefix operator, which evaluates to the modified value, or as a postfix operator, which evaluates to the original value:

\begin{lstlisting}
var a = 10;
trace(a++); // 10
trace(a); // 11

a = 10;
trace(++a); // 11
trace(a); // 11
\end{lstlisting}


\subsection{Binary Operators}
\label{expression-operators-binops}

\paragraph{Arithmetic operators}

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Operator & Operation & Operand 1 & Operand 2 & Result type \\ \hline
	\expr{\%} & modulo & \type{Float/Int} & \type{Float/Int} & \type{Float/Int} \\
	\expr{*} & multiplication & \type{Float/Int} & \type{Float/Int} & \type{Float/Int} \\
	\expr{/} & division & \type{Float/Int} & \type{Float/Int} & \type{Float} \\
	\expr{+} & addition & \type{Float/Int} & \type{Float/Int} & \type{Float/Int} \\
	\expr{-} & subtraction & \type{Float/Int} & \type{Float/Int} & \type{Float/Int}
\end{tabular}
\end{center}

About the \type{Float/Int} return type: If one of the operands is of type \type{Float}, the resulting expression will also be of type \type{Float}, otherwise the type will be \type{Int}. The result of a division is always a \type{Float}; use \expr{Std.int(a / b)} for integer division (discarding any fractional part).

In Haxe, the result of a modulo operation always keeps the sign of the dividend (the left operand) if the divisor is non-negative. The result is target-specific with a negative divisor.

\paragraph{Bitwise operators}

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Operator & Operation & Operand 1 & Operand 2 & Result type \\ \hline
	\expr{<<} & shift left & \type{Int} & \type{Int} & \type{Int} \\
	\expr{>>} & shift right & \type{Int} & \type{Int} & \type{Int} \\
	\expr{>>>} & unsigned shift right & \type{Int} & \type{Int} & \type{Int} \\
	\expr{\&} & bitwise and & \type{Int} & \type{Int} & \type{Int} \\
	\expr{|} & bitwise or & \type{Int} & \type{Int} & \type{Int} \\
	\expr{\^} & bitwise xor & \type{Int} & \type{Int} & \type{Int}
\end{tabular}
\end{center}

\paragraph{Logical operators}

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Operator & Operation & Operand 1 & Operand 2 & Result type \\ \hline
	\expr{\&\&} & logical and & \type{Bool} & \type{Bool} & \type{Bool} \\
	\expr{||} & logical or & \type{Bool} & \type{Bool} & \type{Bool}
\end{tabular}
\end{center}

\emph{Short-circuiting:}

Haxe guarantees that compound boolean expressions with the same operator are evaluated from left to right and only as far as necessary at run-time. For instance, an expression like \expr{A \&\& B} will evaluate \expr{A} first and evaluate \expr{B} only if the evaluation of \expr{A} yielded \expr{true}. Likewise, the expressions \expr{A || B} will not evaluate \expr{B} if the evaluation of \expr{A} yielded \expr{true}, because the value of \expr{B} is irrelevant in that case. This is important in cases such as this:

\begin{lstlisting}
if (object != null && object.field == 1) { }
\end{lstlisting}

Accessing \expr{object.field} if \expr{object} is \expr{null} would lead to a run-time error, but the check for \expr{object != null} guards against it.

\paragraph{Compound assignment operators}

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Operator & Operation & Operand 1 & Operand 2 & Result type \\ \hline
	\expr{\%=} & modulo & \type{Float/Int} & \type{Float/Int} & \type{Float/Int} \\
	\expr{*=} & multiplication & \type{Float/Int} & \type{Float/Int} & \type{Float/Int} \\
	\expr{/=} & division & \type{Float} & \type{Float/Int} & \type{Float} \\
	\expr{+=} & addition & \type{Float/Int} & \type{Float/Int} & \type{Float/Int} \\
	\expr{-=} & subtraction & \type{Float/Int} & \type{Float/Int} & \type{Float/Int} \\
	\expr{<<=} & shift left & \type{Int} & \type{Int} & \type{Int} \\
	\expr{>>=} & shift right & \type{Int} & \type{Int} & \type{Int} \\
	\expr{>>>=} & unsigned shift right & \type{Int} & \type{Int} & \type{Int} \\
	\expr{\&=} & bitwise and & \type{Int} & \type{Int} & \type{Int} \\
	\expr{|=} & bitwise or & \type{Int} & \type{Int} & \type{Int} \\
	\expr{\^=} & bitwise xor & \type{Int} & \type{Int} & \type{Int}
\end{tabular}
\end{center}

In all cases, a compound assignment modifies the given variable, field, structure member, etc., so it will not work on a read-only value. The compound assignment evaluates to the modified value when used as a sub-expression:

\begin{lstlisting}
var a = 3;
trace(a += 3); // 6
trace(a); // 6
\end{lstlisting}

Note that the first operand of \expr{/=} must always be a \type{Float}, since the result of a division is always a \type{Float} in Haxe. Similarly, \expr{+=} and \expr{-=} cannot accept \type{Int} as the first operand if \type{Float} is given as the second operand, since the result would be a \type{Float}.

\paragraph{Numeric comparison operators}

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Operator & Operation & Operand 1 & Operand 2 & Result type \\ \hline
	\expr{==} & equal & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\
	\expr{!=} & not equal & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\
	\expr{<} & less than & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\
	\expr{<=} & less than or equal & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\
	\expr{>} & greater than & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\
	\expr{>=} & greater than or equal & \type{Float/Int} & \type{Float/Int} & \type{Bool}
\end{tabular}
\end{center}

\paragraph{String comparison operators}

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Operator & Operation & Operand 1 & Operand 2 & Result type \\ \hline
	\expr{==} & equal & \type{String} & \type{String} & \type{Bool} \\
	\expr{!=} & not equal & \type{String} & \type{String} & \type{Bool} \\
	\expr{<} & lexicographically before & \type{String} & \type{String} & \type{Bool} \\
	\expr{<=} & lexicographically before or equal & \type{String} & \type{String} & \type{Bool} \\
	\expr{>} & lexicographically after & \type{String} & \type{String} & \type{Bool} \\
	\expr{>=} & lexicographically after or equal & \type{String} & \type{String} & \type{Bool}
\end{tabular}
\end{center}

Two values of type \type{String} are considered equal in Haxe when they have the same length and the same contents:

\begin{lstlisting}
var a = "foo";
var b = "bar";
var c = "foo";
trace(a == b); // false
trace(a == c); // true
trace(a == "foo"); // true
\end{lstlisting}

\paragraph{Equality operators}

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Operator & Operation & Operand 1 & Operand 2 & Result type \\ \hline
	\expr{==} & equal & any & any & \type{Bool} \\
	\expr{!=} & not equal & any & any & \type{Bool}
\end{tabular}
\end{center}

The types of operand 1 and operand 2 must \tref{unify}{type-system-unification}.

\emph{Enums:}

\begin{description}
	\item[Enums without parameters] always represent the same value, so \expr{MyEnum.A == MyEnum.A}. 
	\item[Enums with parameters] can be compared with \expr{a.equals(b)} (which is short for \expr{Type.enumEquals()}).
\end{description}

\emph{Dynamic:}

Comparison involving at least one operand of type \type{Dynamic} is unspecified and platform-specific.

\paragraph{Miscellaneous operators}

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Operator & Operation & Operand~1 & Operand~2 & Result~type \\ \hline
	\expr{...} & interval (see \tref{range iteration}{expression-for}) & \type{Int} & \type{Int} & \type{IntIterator} \\
	\expr{=>} & arrow (see \tref{map}{expression-map-declaration}, \tref{key-value iteration}{expression-for}, \tref{map comprehension}{lf-map-comprehension}) & any & any & -
\end{tabular}
\end{center}


\subsection{Ternary Operator}
\label{expression-operators-ternary}

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Operator & Operation & Operand 1 & Operand 2 & Operand 3 & Result type \\ \hline
	\expr{?:} & condition & \type{Bool} & any & any & any
\end{tabular}
\end{center}

The type of operand 1 and operand 2 must \tref{unify}{type-system-unification}. The unified type is used as the result type of the expression.

The ternary conditional operator is a shorter form of \tref{\expr{if}}{expression-if}:

\begin{lstlisting}
trace(true ? "Haxe" : "Neko"); // Haxe
trace(1 == 2 ? 3 : 4); // 4

// equivalent to:

trace(if (true) "Haxe" else "Neko"); // Haxe
trace(if (1 == 2) 3 else 4); // 4
\end{lstlisting}


\subsection{Precedence}
\label{expression-operators-precedence}

In order of descending precedence (i.e. operators higher in the table are evaluated first):

\begin{center}
\begin{tabular}{| l | l |}
	\hline
	Operators & Note & Associativity \\ \hline
	\expr{!}, \expr{++}, \expr{--} & postfix unary operators & right \\
	\expr{\textasciitilde}, \expr{!}, \expr{-}, \expr{++}, \expr{--} & prefix unary operators & right \\
	\expr{\%} & modulo & left \\
	\expr{*}, \expr{/} & multiplication, division & left \\
	\expr{+}, \expr{-} & addition, subtraction & left \\
	\expr{<<}, \expr{>>}, \expr{>>>} & bitwise shifts & left \\
	\expr{\&}, \expr{|}, \expr{\^} & bitwise operators & left \\
	\expr{==}, \expr{!=}, \expr{<}, \expr{<=}, \expr{>}, \expr{>=} & comparison & left \\
	\expr{...} & interval & left \\
	\expr{\&\&} & logical and & left \\
	\expr{||} & logical or & left \\
	\expr{@} & metadata & right \\
	\expr{?:} & ternary & right \\
	\expr{\%=}, \expr{*=}, \expr{/=}, \expr{+=}, \expr{-=}, \expr{<<=}, \expr{>>=}, \expr{>>>=}, \expr{\&=}, \expr{|=}, \expr{\^=} & compound assignment & right \\
	\expr{=>} & arrow & right \\
\end{tabular}
\end{center}

\paragraph{Differences from C-like precedence}

Many languages (C++, Java, PHP, JavaScript, etc) use the same operator precedence rules as C. In Haxe, there are a couple of differences from these rules:

\begin{itemize}
	\item \expr{\%} (modulo) has a higher precedence than \expr{*} and \expr{/}; in C they have the same precedence
	\item \expr{|}, \expr{\&}, \expr{\^} (bitwise operators) have the same precedence; in C the three operators all have a different precedence
	\item \expr{|}, \expr{\&}, \expr{\^} (bitwise operators) also have a lower precedence than \expr{==}, \expr{!=}, etc (comparison operators)
\end{itemize}


\subsection{Overloading and macros}
\label{expression-operators-overloading}

The operators specified in the previous sections specify the types and meanings for operations on basic types. Additional functionality can be implemented using \tref{abstract operator overloading}{types-abstract-operator-overloading} or \tref{macro processing}{macro}.

Operator precedence cannot be changed with abstract operator overloading.

For macro processing in particular, there is an additional operator available: the postfix \expr{!} operator.


\section{Array Declaration}
\label{expression-array-declaration}

Arrays are initialized by enclosing comma \expr{,} separated values in brackets \expr{[]}. A plain \expr{[]} represents the empty array, whereas \expr{[1, 2, 3]} initializes an array with three elements \expr{1}, \expr{2} and \expr{3}.

The generated code may be less concise on platforms that do not support array initialization. Essentially, such initialization code then looks like this:

\begin{lstlisting}
var a = new Array();
a.push(1);
a.push(2);
a.push(3);
\end{lstlisting}
This should be considered when deciding if a function should be \tref{inlined}{class-field-inline} as it may inline more code than visible in the syntax.

Advanced initialization techniques are described in \Fullref{lf-array-comprehension}.

\section{Map Declaration}
\label{expression-map-declaration}

Maps are initialized similarly to arrays, but include both keys and their corresponding values. \expr{["example" => 1, "data" => 2]} initializes a map (\type{Map<String, Int>} specifically) where the key \expr{"example"} stores the value \expr{1} and \expr{"data"} stores the value 2.

\since{4.0.0}

Where a map type is expected (based on \tref{top-down inference}{type-system-top-down-inference}), \expr{[]} refers to an empty map.


\section{Object Declaration}
\label{expression-object-declaration}

Object declaration begins with an opening curly brace \expr{\{} after which \expr{key:value}-pairs separated by comma \expr{,} follow, and which ends in a closing curly brace \expr{\}}.

\begin{lstlisting}
{
	key1:value1,
	key2:value2,
	...
	keyN:valueN
}
\end{lstlisting}
Further details of object declaration are described in the section about \tref{anonymous structures}{types-anonymous-structure}.


\section{Field Access}
\label{expression-field-access}

Field access is expressed by using the dot \expr{.} followed by the name of the field.

\begin{lstlisting}
object.fieldName
\end{lstlisting}

This syntax is also used to access types within packages in the form of \expr{pack.Type}.

The typer ensures that an accessed field actually exist and may apply transformations depending on the nature of the field. If a field access is ambiguous, understanding the \tref{resolution order}{type-system-resolution-order} may help.


\section{Array Access}
\label{expression-array-access}

Array access is expressed by using an opening bracket \expr{[} followed by the index expression and a closing bracket \expr{]}.

\begin{lstlisting}
expr[indexExpr]
\end{lstlisting}

This notation is allowed with arbitrary expressions, but at typing level only certain combinations are admitted:

\begin{itemize}
	\item \expr{expr} is of \type{Array} or \type{Dynamic} and \expr{indexExpr} is of \type{Int}
	\item \expr{expr} is an \tref{abstract type}{types-abstract} which defines a matching \tref{array access}{types-abstract-array-access}
\end{itemize}


\section{Function Call}
\label{expression-function-call}

Functions calls consist of an arbitrary subject expression followed by an opening parenthesis \expr{(}, a comma \expr{,} separated list of expressions as arguments and a closing parenthesis \expr{)}.

\begin{lstlisting}
subject(); // call with no arguments
subject(e1); // call with one argument
subject(e1, e2); // call with two arguments
// call with multiple arguments
subject(e1, ..., eN);
\end{lstlisting}


\paragraph{Related content}
\begin{itemize}
	\item Haxe Code Cookbook article: \href{http://code.haxe.org/category/beginner/declare-functions.html}{How to declare functions}
	\item Class Methods: \Fullref{class-field-method}
\end{itemize}


\section{var and final}
\label{expression-var}

The \expr{var} keyword allows declaring multiple variables, separated by comma \expr{,}. Each variable has a valid \tref{identifier}{define-identifier} and optionally a value assignment following the assignment operator \expr{=}. Variables can also have an explicit type-hint.

\begin{lstlisting}
var a; // declare local a
var b:Int; // declare variable b of type Int
// declare variable c, initialized to value 1
var c = 1;
// declare an uninitialized variable d
// and variable e initialized to value 2
var d,e = 2;
\end{lstlisting}

The scoping behavior of local variables, as well as variable shadowing is described in \Fullref{expression-block}.

\since{4.0.0}

In Haxe 4, the alternative keyword \expr{final} was introduced at the expression level. Variables declared with \expr{final} instead of \expr{var} can only be assigned a value once.

\haxe{assets/Final.hx}

It is important to note that \expr{final} may not have the intended effect with types that are not immutable, such as arrays or objects. Even though the variable cannot have a different object assigned to it, the object itself can still be modified using its methods:

\haxe{assets/FinalMutable.hx}


\section{Local Functions}
\label{expression-function}

Haxe supports first-class functions and allows declaring local functions in expressions. The syntax follows \tref{class field methods}{class-field-method}:

\haxe{assets/LocalFunction.hx}

We declare \expr{myLocalFunction} inside the \tref{block expression}{expression-block} of the \expr{main} class field. It takes one argument \expr{i} and adds it to \expr{value}, which is defined in the outside scope.

The scoping is equivalent to that of \tref{variables}{expression-var} and for the most part writing a named local function can be considered equal to assigning an unnamed local function to a local variable:

\begin{lstlisting}
var myLocalFunction = function(a) { }
\end{lstlisting}

However, there are some differences related to type parameters and the position of the function. We speak of a ``lvalue'' function if it is not assigned to anything upon its declaration, and an ``rvalue'' function otherwise.

\begin{itemize}
	\item Lvalue functions require a name and can have \tref{type parameters}{type-system-type-parameters}.
	\item Rvalue functions may have a name, but cannot have type parameters.
\end{itemize}

\since{4.0.0}

\label{expression-arrow-function}
\paragraph{Arrow functions}

Haxe 4 introduced a shorter syntax for defining local functions without a name, very similar to the function type syntax. The argument list is defined between two parentheses, followed by an arrow \expr{->}, followed directly by the expression. An arrow function with a single argument does not require parentheses around the argument, and an arrow function with zero arguments should be declared with \expr{() -> ...}:

\haxe{assets/ArrowFunction.hx}

Arrow functions are very similar to normal local functions, with a couple of differences:

\begin{itemize}
	\item The expression after the arrow is implicitly treated as the return value of the function. For simple functions like \expr{myConcat} above, this can be a convenient way to shorten the code. Normal \expr{return} expressions can still be used, as shown in \expr{myContains} above.
	\item There is no way to declare the return type, although you can use a \tref{type check}{expression-type-check} to unify the function expression with the desired return type.
	\item \tref{Metadata}{lf-metadata} cannot be applied to the arguments of an arrow function.
\end{itemize}


\section{new}
\label{expression-new}

The \expr{new} keyword signals that a \tref{class}{types-class-instance} or an \tref{abstract}{types-abstract} is being instantiated. It is followed by the \tref{type path}{define-type-path} of the type which is to be instantiated. It may also list explicit \tref{type parameters}{type-system-type-parameters} enclosed in \expr{<>} and separated by comma \expr{,}. After an opening parenthesis \expr{(} follow the constructor arguments, again separated by comma \expr{,}, with a closing parenthesis \expr{)} at the end.

\haxe{assets/New.hx}

Within the \expr{main} method we instantiate an instance of \type{Main} itself, with an explicit type parameter \type{Int} and the arguments \expr{12} and \expr{"foo"}. As we can see, the syntax is very similar to the \tref{function call syntax}{expression-function-call} and it is common to speak of ``constructor calls''.



\section{for}
\label{expression-for}

Haxe does not support traditional for-loops known from C. Its \expr{for} keyword expects an opening parenthesis \expr{(}, then a variable identifier followed by the keyword \expr{in} and an arbitrary expression used as iterating collection. After the closing parenthesis \expr{)} follows an arbitrary loop body expression.

\begin{lstlisting}
for (v in e1) e2;
\end{lstlisting}

The typer ensures that the type of \expr{e1} can be iterated over, which is typically the case if it has an  \tref{\expr{iterator}}{lf-iterators} method returning an \type{Iterator<T>}, or if it is an \type{Iterator<T>} itself.

Variable \expr{v} is then available within loop body \expr{e2} and holds the value of the individual elements of collection \expr{e1}.

\begin{lstlisting}
var list = ["apple", "pear", "banana"];
for (v in list) {
  trace(v);
}
// apple
// pear
// banana
\end{lstlisting}

\paragraph{Range iteration}

Haxe has a special range operator to iterate over intervals. It is a binary operator taking two \type{Int} operands: \expr{min...max} returns an \href{http://api.haxe.org/IntIterator.html}{IntIterator} instance that iterates from \expr{min} (inclusive) to \expr{max} (exclusive). Note that \expr{max} may not be smaller than \expr{min}.

\begin{lstlisting}
for (i in 0...10) trace(i); // 0 to 9
\end{lstlisting}

The type of a \expr{for} expression is always \type{Void}, meaning it has no value and cannot be used as right-side expression. However, we'll later introduce \tref{array comprehension}{lf-array-comprehension}, which lets you construct arrays using \expr{for} expressions.

The control flow of loops can be affected by \tref{\expr{break}}{expression-break} and \tref{\expr{continue}}{expression-continue} expressions.

\begin{lstlisting}
for (i in 0...10) {
  if (i == 2) continue; // skip 2
  if (i == 5) break; // stop at 5
  trace(i);
}
// 0
// 1
// 3
// 4
\end{lstlisting}

\since{4.0.0}

\paragraph{Key-value iteration}
\label{expression-for-keyvalue}

In Haxe 4 it is possible to iterate over collections of key-value pairs. The syntax is the same as regular \expr{for} loops, but the single variable identifier is replaced with the key variable identifier, followed by \expr{=>}, followed by the value variable identifier:

\begin{lstlisting}
for (k => v in e1) e2;
\end{lstlisting}

Type safety is ensured for key-value iteration as well. The typer checks that \expr{e1} either has a \expr{keyValueIterator} method returning returning a \type{KeyValueIterator<K, V>}, or if it is a \type{KeyValueIterator<K, V>} itself. Here \type{K} and \type{V} refer to the type of the keys and the values, respectively.

\begin{lstlisting}
var map = [1 => 101, 2 => 102, 3 => 103];
for (key => value in map) {
  trace(key, value);
}
// 1, 101
// 2, 102
// 3, 103
\end{lstlisting}

\paragraph{Related content}
\begin{itemize}
	\item Manual: \tref{Haxe iterators documentation}{lf-iterators}, \tref{Haxe Data Structures documentation}{std-ds}
	\item Cookbook: \href{http://code.haxe.org/tag/iterator.html}{Haxe iterators examples}, \href{http://code.haxe.org/tag/data-structures.html}{Haxe data structures examples}
\end{itemize}

\section{while}
\label{expression-while}

A normal while loop starts with the \expr{while} keyword, followed by an opening parenthesis \expr{(}, the condition expression and a closing parenthesis \expr{)}. After that follows the loop body expression:

\begin{lstlisting}
while(condition) expression;
\end{lstlisting}

The condition expression has to be of type \type{Bool}.

Upon each iteration, the condition expression is evaluated. If it evaluates to \expr{false}, the loop stops, otherwise it evaluates the loop body expression.

\haxe{assets/While.hx}

This kind of while-loop is not guaranteed to evaluate the loop body expression at all: If the condition does not hold from the start, it is never evaluated. This is different for \tref{do-while loops}{expression-do-while}.

\section{do-while}
\label{expression-do-while}

A do-while loop starts with the \expr{do} keyword followed by the loop body expression. After that follows the \expr{while} keyword, an opening parenthesis \expr{(}, the condition expression and a closing parenthesis \expr{)}:

\begin{lstlisting}
do expression while(condition);
\end{lstlisting}

The condition expression has to be of type \type{Bool}.

As the syntax suggests, the loop body expression is always evaluated at least once, unlike \tref{while}{expression-while} loops.

\section{if}
\label{expression-if}

Conditional expressions come in the form of a leading \expr{if} keyword, a condition expression enclosed in parentheses \expr{()} and a expression to be evaluated in case the condition holds:

\begin{lstlisting}
if (condition) expression;
\end{lstlisting}

The condition expression has to be of type \type{Bool}.

Optionally, \expr{expression} may be followed by the \expr{else} keyword as well as another expression to be evaluated if the condition does not hold:

\begin{lstlisting}
if (condition) expression1 else expression2;
\end{lstlisting}

Here, \expr{expression2} may consist of another \expr{if} expression:

\begin{lstlisting}
if (condition1) expression1
else if(condition2) expression2
else expression3
\end{lstlisting}

If the value of an \expr{if} expression is required, e.g. for \expr{var x = if(condition) expression1 else expression2}, the typer ensures that the types of \expr{expression1} and \expr{expression2} \tref{unify}{type-system-unification}. If no \expr{else} expression is given, the type is inferred to be \type{Void}.


\section{switch}
\label{expression-switch}

A basic switch expression starts with the \expr{switch} keyword and the switch subject expression, as well as the case expressions between curly braces \expr{\{\}}. Case expressions either start with the \expr{case} keyword and are followed by a pattern expression, or consist of the \expr{default} keyword. In both cases a colon \expr{:} and an optional case body expression follows:

\begin{lstlisting}
switch subject {
	case pattern1: case-body-expression-1;
	case pattern2: case-body-expression-2;
	default: default-expression;
}
\end{lstlisting}

Case body expressions never ``fall through'', so the \tref{\expr{break}}{expression-break} keyword is not supported in Haxe.

Switch expressions can be used as value; in that case the types of all case body expressions and the default expression must \tref{unify}{type-system-unification}.

\paragraph{Related content}
\begin{itemize}
	\item Further details on syntax of pattern expressions are detailed in \Fullref{lf-pattern-matching}.
	\item \href{http://code.haxe.org/tag/pattern-matching.html}{Snippets and tutorials about pattern matching} in the Haxe Code Cookbook.
\end{itemize}


\section{try/catch}
\label{expression-try-catch}

Haxe allows catching values using its \expr{try/catch} syntax:

\begin{lstlisting}
try try-expr
catch(varName1:Type1) catch-expr-1
catch(varName2:Type2) catch-expr-2
\end{lstlisting}

If during runtime the evaluation of \expr{try-expression} causes a \tref{\expr{throw}}{expression-throw}, it can be caught by any subsequent \expr{catch} block. These blocks consist of

\begin{itemize}
	\item a variable name which holds the thrown value,
	\item an explicit type annotation which determines which types of values to catch, and
	\item the expression to execute in that case.
\end{itemize}

Haxe allows throwing and catching any kind of value, it is not limited to types inheriting from a specific exception or error class. Catch blocks are checked from top to bottom with the first one whose type is compatible with the thrown value being picked.

This process has many similarities to the compile-time \tref{unification}{type-system-unification} behavior. However, since the check has to be done at runtime there are several restrictions:

\begin{itemize}
	\item The type must exist at runtime: \tref{Class instances}{types-class-instance}, \tref{enum instances}{types-enum-instance}, \tref{abstract core types}{types-abstract-core-type} and \tref{Dynamic}{types-dynamic}.
	\item Type parameters can only be \tref{Dynamic}{types-dynamic}.
\end{itemize}



\section{return}
\label{expression-return}

A \expr{return} expression can come with or without a value expression:

\begin{lstlisting}
return;
return expression;
\end{lstlisting}

It leaves the control-flow of the innermost function it is declared in, which has to be distinguished when \tref{local functions}{expression-function} are involved:

\begin{lstlisting}
function f1() {
	function f2() {
		return;
	}
	f2();
	expression;
}
\end{lstlisting}

The \expr{return} leaves local function \expr{f2}, but not \expr{f1}, meaning \expr{expression} is still evaluated.

If \expr{return} is used without a value expression, the typer ensures that the return type of the function it returns from is of \type{Void}. If it has a value expression, the typer \tref{unifies}{type-system-unification} its type with the return type (explicitly given or inferred by previous \expr{return} expressions) of the function it returns from.


\section{break}
\label{expression-break}

The \expr{break} keyword leaves the control flow of the innermost loop (\expr{for} or \expr{while}) it is declared in, stopping further iterations:

\begin{lstlisting}
while(true) {
	expression1;
	if (condition) break;
	expression2;
}
\end{lstlisting}

Here, \expr{expression1} is evaluated for each iteration, but as soon as \expr{condition} holds, the current iteration is terminated without evaluating \expr{expression2}, and no more iteration is done.

The typer ensures that it appears only within a loop. The \expr{break} keyword in \tref{\expr{switch} cases}{expression-switch} is not supported in Haxe.


\section{continue}
\label{expression-continue}

The \expr{continue} keyword ends the current iteration of the innermost loop (\expr{for} or \expr{while}) it is declared in, causing the loop condition to be checked for the next iteration:

\begin{lstlisting}
while(true) {
	expression1;
	if(condition) continue;
	expression2;
}
\end{lstlisting}

Here, \expr{expression1} is evaluated for each iteration, but if \expr{condition} holds, \expr{expression2} is not evaluated for the current iteration. Unlike \expr{break}, iterations continue.

The typer ensures that it appears only within a loop.


\section{throw}
\label{expression-throw}

Haxe allows throwing any kind of value using its \expr{throw} syntax:

\begin{lstlisting}
throw expr
\end{lstlisting}

A value which is thrown like this can be caught by \tref{\expr{catch} blocks}{expression-try-catch}. If no such block catches it, the behavior is target-dependent.


\section{cast}
\label{expression-cast}

Haxe allows two kinds of casts:

\begin{lstlisting}
cast expr; // unsafe cast
cast (expr, Type); // safe cast
\end{lstlisting}

\subsection{unsafe cast}
\label{expression-cast-unsafe}

Unsafe casts are useful to subvert the type system. The compiler types \expr{expr} as usual and then wraps it in a \tref{monomorph}{types-monomorph}. This allows the expression to be assigned to anything.

Unsafe casts do not introduce any \tref{dynamic}{types-dynamic} types, as the following example shows:

\haxe{assets/UnsafeCast.hx}

Variable \expr{i} is typed as \type{Int} and then assigned to variable \expr{s} using the unsafe cast \expr{cast i}. This causes \expr{s} to be of an unknown type, a monomorph. Following the usual rules of \tref{unification}{type-system-unification}, it can then be bound to any type, such as \type{String} in this example.

These casts are called "unsafe" because the runtime behavior for invalid casts is not defined. While most \tref{dynamic targets}{define-dynamic-target} are likely to work, it might lead to undefined errors on \tref{static targets}{define-static-target}.

Unsafe casts have little to no runtime overhead.

\subsection{safe cast}
\label{expression-cast-safe}

Unlike \tref{unsafe casts}{expression-cast-unsafe}, the runtime behavior in case of a failing cast is defined for safe casts:

\haxe{assets/SafeCast.hx}

In this example we first cast a class instance of type \type{Child1} to \type{Base}, which succeeds because \type{Child1} is a \tref{child class}{types-class-inheritance} of \type{Base}. We then try to cast the same class instance to \type{Child2}, which is not allowed because instances of \type{Child2} are not instances of \type{Child1}.

The Haxe compiler guarantees that an exception of type \type{String} is \tref{thrown}{expression-throw} in this case. This exception can be caught using a \tref{\expr{try/catch} block}{expression-try-catch}.

Safe casts have a runtime overhead. It is important to understand that the compiler already generates type checks, so it is redundant to add manual checks, e.g. using \expr{Std.is}. The intended usage is to try the safe cast and catch the \type{String} exception.


\section{type check}
\label{expression-type-check}
\since{3.1.0}

It is possible to employ compile-time type checks using the following syntax:

\begin{lstlisting}
(expr : type)
\end{lstlisting}

The parentheses are mandatory. Unlike \tref{safe casts}{expression-cast-safe} this construct has no run-time impact. It has two compile-time implications:

\begin{enumerate}
\item \tref{Top-down inference}{type-system-top-down-inference} is used to type \expr{expr} with type \expr{type}.
\item The resulting typed expression is \tref{unified}{type-system-unification} with type \expr{type}.
\end{enumerate}

This has the usual effect of both operations such as the given type being used as expected type when performing \tref{unqualified identifier resolution}{type-system-resolution-order} and the unification checking for \tref{abstract casts}{types-abstract-implicit-casts}.


\section{inline}
\label{expression-inline}
\since{4.0.0}

The \expr{inline} keyword can be used before a \tref{function call}{expression-function-call} or a \tref{constructor call}{expression-new}. This allows a finer-grained control of inlining, unlike the \tref{inline access modifier}{class-field-inline}.

\haxe{assets/InlineCallsite.hx}

The generated JavaScript output is:

\begin{lstlisting}
(function ($global) { "use strict";
var Test = function() { };
Test.mid = function(s1,s2) {
	return (s1 + s2) / 2;
};
Test.main = function() {
	var a = 1;
	var b = 2;
	var c = Test.mid(a,b);
	var d = (a + b) / 2;
};
Test.main();
})({});
\end{lstlisting}

Note that \expr{c} produces a call to the function, whereas \expr{d} does not. The usual warnings about what makes a good candidate for inlining still hold (see \Fullref{class-field-inline}).

An \expr{inline new} call can be used to avoid creating a local class instance. See \Fullref{lf-inline-constructor} for more details.

